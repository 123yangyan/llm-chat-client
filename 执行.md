## 激活
venv\Scripts\activate
## 进入后端
cd llm_api_project
python server.py

## mcp
python examples/mcp_example.py

## 进入系统
python run.py





下面给出一个“循序渐进、可随时回滚”的重构分解 Roadmap。  
每一步都能够独立合并到主分支，并提供最小可运行的系统。若资源允许，建议在 Git 分支中按序完成并设立 CI 自动测试，以确保稳定。  

──────────────────────────  
STEP 0 基线快照  
• 新建 main 分支 tag：v0_snapshot，保存现状。  
• 引入预设 CI（lint+单测占位），保证后续步骤可自动验证启动成功：  
  `pytest -q`, `uvicorn backend.app.main:app --host 0.0.0.0 --port 8000 --lifespan on`, `npm run build`（前端若有）。  

──────────────────────────  
STEP 1 抽离 FastAPI 入口（10min）  
目标：server.py 只保留路由逻辑，FastAPI 实例转移到新的 backend/app/main.py。  
1. 新目录 `backend/app`；在其中创建：  
  ```python
  # backend/app/main.py
  from fastapi import FastAPI
  def get_app() -> FastAPI:
      from .routers import register_routers
      app = FastAPI()
      register_routers(app)
      return app
  app = get_app()
  ```  
2. 把 server.py 中的 CORS、中间件、路由函数剪切到 `backend/app/routers/__init__.py`，保留 import 路径。  
3. run.py 改为 `uvicorn backend.app.main:app ...`。  
验证：CI 启动通过；功能与旧版一致。

──────────────────────────  
STEP 2 统一配置读取（20–30min）  
目标：消除多源冲突，使用 Pydantic BaseSettings。  
1. 新建 `backend/app/core/config.py`：  
  ```python
  from pydantic_settings import BaseSettings, SettingsConfigDict
  class Settings(BaseSettings):
      server_host: str = "0.0.0.0"
      server_port: int = 8000
      default_provider: str = "silicon"
      class Config: 
          env_file = ".env"
  settings = Settings()
  ```  
2. 替换 server.py / manager.py / config.py 中的 `os.getenv("DEFAULT_PROVIDER"...` 等调用，改为 `settings.default_provider`。  
3. 将旧的 llm_api_project/config.py 标记为 deprecated；保留接口但内部调用新 Settings 以避免破坏现有 import。  
验证：本地跑 `uvicorn`, 环境变量覆盖正常。

──────────────────────────  
STEP 3 Provider 插件化（≈1h）  
目标：剥离 LLMManager 的 Provider 创建逻辑。  
1. 在 `backend/app/providers/base.py` 中保留抽象类（现有 llm_interface.py 可直接搬迁）。  
2. silicon_provider.py、google_provider.py 等移动到 `backend/app/providers/impl/`，继承 BaseProvider。  
3. 新建 `ProviderFactory`：根据 settings.default_provider 返回实例。  
4. LLMManager 只存 Provider 实例 & 会话逻辑，不负责创建。  
验证：  
  `POST /api/provider/switch` 能正常切换；`/api/models` 返回无误。

──────────────────────────  
STEP 4 会话存储抽象（约1h）  
目标：把内存 dict 抽象为 Repo 层，为后续接入 Redis 做准备。  
1. 新建 `repositories/session_base.py` + `repositories/in_memory.py`。  
2. LLMManager 改为依赖注入 SessionRepo（缺省 InMemoryRepo）。  
3. 在 main.py 使用 FastAPI DEPENDS 提供 Repo 单例。  
验证：并发两次请求得到相同 session_id，历史正确累积。

──────────────────────────  
STEP 5 导出功能分层（≈40min）  
目标：将 PDF/Word 逻辑移出路由，便于单测与复用。  
1. `services/export_service.py`：包含 `generate_pdf`, `generate_docx` 函数；依赖 Settings 中的 wkhtmltopdf_path。  
2. 路由 `/api/export` 改为调用 service 并返回 FileResponse。  
验证：上传同样 payload 结果文件一致。

──────────────────────────  
STEP 6 拆分前端与静态文件挂载（≈30min）  
目标：后端只处理 API，不再 mount build 结果。  
1. 删除 `app.mount("/", StaticFiles(...))`。  
2. 在 README 说明前端独立启动，如 `npm run dev` 或 nginx build。  
3. 若仍需一体化，在 docker-compose 用 nginx 服务静态资源。  
验证：后端仍可健康启动；前端能通过环境变量 VITE_API_URL 调用 API。

──────────────────────────  
STEP 7 Docker 化 & 多实例可横向扩展（可并行）  
1. backend/Dockerfile + docker-compose.yml 引入 Redis。  
2. 新增 `repositories/redis_repo.py`；在 Settings 中添加 redis_url。  
3. 生产 compose 使用 redis_repo；dev 默认内存。  

──────────────────────────  
STEP 8 CI / CD 扩展  
• GitHub Actions：lint → test → build backend image → push docker hub。  
• 前端另设 workflow。  

──────────────────────────  
回滚策略  
1) 每个 STEP 完成后打 tag，如 v1_provider_refactor；任何稳定性问题可 `git checkout` 快速回退。  
2) 依赖注入＋适配器保证旧接口可继续使用，最大限度减小破坏面。  
3) CI 自动回归测试作为安全网。  

以上步骤均可按团队节奏逐一实施；如需示例代码 patch 或具体文件搬迁脚本，请继续说明！



下面给出一个“4 周冲刺”代码优化路线图，每一步都是可独立合并的 PR，并附带衡量指标。按照优先级从易到难、从高收益到低收益推进。

──────────────────────
WEEK 1　代码可读性 & 注释

STEP 1-A（Day 1-2）  
目标：核心公共接口补齐 Docstring  
• 范围：backend/app/**、llm_api_project/** 下暴露给外部调用的类 / 函数  
• 动作：  
  – 按 Google-Style 或 reST 编写 Docstring  
  – CI 中加入 `ruff --select D`（文档规范）  
• 验收：`ruff` 通过率 100 %

STEP 1-B（Day 3-4）  
目标：统一日志格式  
• 引入 `structlog` 或标准 `logging` 配置  
• LLMManager、Provider、Server 路由统一用 logger  
• CI 检查不得出现 `print()`  

──────────────────────
WEEK 2　复杂度 & 结构拆分

STEP 2-A（Day 5-6）  
目标：拆分 server.py  
• 新建 `backend/app/api/v1/routers/chat.py`、`export.py`  
• `app.include_router()` 注册  
• server.py 只保留 create_app 与 run_server（<150 行）  
• 验收：radon 复杂度 ≤ B（<10）  

STEP 2-B（Day 7）  
目标：重构 LLMManager.chat_with_memory  
• 提取私有方法：  
  1. `_build_prompt()`  
  2. `_call_provider()`  
  3. `_update_history()`  
• 覆盖率 >= 80 % 的单测  

──────────────────────
WEEK 3　错误处理 & 重复代码

STEP 3-A（Day 8-9）  
目标：FastAPI 全局异常处理中间件  
• 捕获 ValidationError、ProviderError、未知异常  
• 返回统一 JSON：`{code, message, data}`  
• 记录堆栈到 logger.error

STEP 3-B（Day 10）  
目标：导出逻辑去重  
• 使用 Jinja2 模板 `export.html.j2` 生成 PDF/HTML  
• Word 样式封装到 `word_styles.py`  
• 重复字符串 ↓ 70 %

──────────────────────
WEEK 4　持久化 & 质量门禁

STEP 4-A（Day 11-12）  
目标：RedisSessionRepo  
• 实现 `get_history / save_history` 基于 `redis-py`  
• Settings 增加 `redis_url`；通过依赖注入切换  
• docker-compose 已含 redis，单元测试用 `fakeredis`

STEP 4-B（Day 13）  
目标：CI 质量闸门  
• flake8：`--max-complexity 12`  
• radon：`radon cc -n B backend llm_api_project`  
• 单测覆盖率 ≥ 80 %（pytest-cov）  
• 失败即阻断合并

STEP 4-C（Day 14）  
目标：文档 & README  
• 更新架构图、运行方式、API 列表、CI 状态徽章  
• 在 PR 模板中加入 “是否通过质量门禁” 勾选项

──────────────────────
持续度量指标

1. Docstring 覆盖率（ruff-D 0 报错）  
2. radon 复杂度平均 ≤ 8，最大 ≤ 12  
3. pytest 覆盖率 ≥ 80 %  
4. Docker 镜像大小 ≤ 300 MB  
5. 主分支 CI 通过率 100 %

──────────────────────
团队协作建议

• 每个 STEP 建 Feature 分支，提小粒度 PR；  
• 使用 GitHub Projects 看板跟踪；  
• 审核 Checklist：命名、注释、测试、复杂度、日志、异常处理。  

按此节奏执行，整体评分有望从 35 → 70+，屎山异味基本消除。祝优化顺利！
